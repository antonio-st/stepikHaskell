-- Язык Haskell — чистый функциональный язык программирования с «ленивой» семантикой исполнения и полиморфной статической типизацией. Язык назван в честь американского логика и математика Хаскелла Брукса Карри. (Написание Хаскель является в среде русскоязычных пользователей языка общепринятым, хотя и не очень официальным.)
-- 
-- Первая реализация была выпущена в 1990-м году. Текущий стандарт: Haskell 2010. 
-- 
-- https://www.haskell.org/onlinereport/haskell2010/
-- 
-- Сайт haskell.org является полезным и авторитетным источником разнообразной информации о языке.
-- 
-- Справку по функциям стандартной библиотеки (и не только) можно получить с помощью онлайн системы Hoogle. 

-- https://www.haskell.org/hoogle/


--вызов функции 2 аргументов
max 5 42 
результат 42

-- частичное применение функции 2 аргументов max к 5
3 + (max 5) 42
45

-- В стандартной библиотеке Haskell есть функция вычисления логарифма по произвольному основанию logBase. Это функция двух переменных, которой требуется передать основание логарифма и аргумент, на котором логарифм будет вычислен. Какие из следующих вызовов обеспечат вычисление логарифма по основанию 2 от 8

(logBase 2) 8
logBase 2 8
 
-- пользовательская функция 2 аргуметов 
sumSquares x y = x ^ 2 + y ^ 2
sumSquares 1 2


{-
Реализуйте функцию трех аргументов lenVec3, которая вычисляет длину трехмерного вектора. Аргументы функции задают декартовы координаты конца вектора, его начало подразумевается находящимся в начале координат. Для извлечения квадратного корня воспользуйтесь функцией sqrt, определенной в стандартной библиотеке.-}

lenVec3 x y z =  sqrt(x ^ 2 + y ^ 2 + z ^ 2)
Prelude> lenVec3 2 3 6
7.0

-- условный оператор

f x = if x > 0 then 1 else (-1)
Prelude> f 5
1

g x = (if x > 0 then 1 else -1) + 5
Prelude> g 5
6


{-Напишите реализацию функции sign, которая возвращает 1, если ей передано положительное число, (-1), 
если отрицательное, и 0 в случае, когда передан 0.-}

sign x = if x < 0 then (-1) else (if x > 0 then 1 else 0)
sign x = if x == 0 then 0 else if x > 0 then 1 else (-1)

-- многострочный режим
:{
sign2 x
  | x > 0 = 1
  | x == 0 = 0
  | otherwise = - 1
:}


-- аналогично max5 x = max 5 x
max5' = max 5
--функция определения скидки, 
discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum

--функция скидки по умолчанию, применили частичное определение аргументов, в дальнейшем вызываем только с суммой
discount_default = discount 1000 5
-- *Module_1_2> discount_default 2000
-- 1900.0

----------------------- операторы -----------------------

-- оператор как функция
Prelude> (+) 6 7
13

-- фунция как оператор
6 `max` 7

-- унарный и бинарный - (заключать отрицательные числа в скобки)

Prelude> max (-5) 5
5
Prelude> (-) 10 2
8


-- фунция приоритетнее оператора2 : 
Prelude> sin 5 + 2
1.0410757253368614

-- ассоциативность 
-- правая например  для ^,^^,**, : (Append to list), && Logical AND, || Logical OR, =<<, $,$!,`seq`
-- левая: +,-, *,/,`quot`,`rem`,`div`,`mod`, >>,>>=
	
-- Попробуйте вычислить значение выражения 
  (*) 2 ((+) 1 4) ^ 2

  -- 100

-- свои операторы

-- операторный синтаксис(сумма квадратов 2 чисел)
infixl 6 *+*
a *+* b = a ^ 2 + b ^ 2
-- *Demo> 3 *+* 4
-- 25
-- инфиксный синтаксис
infixl 6 *+
(*+) a = a ^ 2

--Реализуйте оператор |-|, который возвращает модуль разности переданных ему аргументов:
infixl 6 |-|
(|-|) a b = abs (a - b)

--сечение оператора
(/ 2) 4
--2.0
-- делить на 2
(/ 2) 4
2.0

-- Попробуйте вычислить значение выражения (`mod` 14) ((+ 5) 10)
-- (`mod` 14) ((+ 5) 10) -> (`mod` 14) 15
--1


